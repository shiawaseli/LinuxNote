进程间通信(IPC) : 操作系统为用户提供了几种进程间通信方式
	进程间因为每一个进程都有一个虚拟地址内存空间，在保证了进程独立性的同时，却使得进程间无法直接通信，
	因此需要操作系统来提供进程间通信方式，并且因为通信场景不同，提供的方式也有多种
	（数据传输，数据共享，进程控制）
进程间通信的种类：
System V标准的通信方式
	管道--用于进程间的数据传输
	共享内存--用于进程间的数据共享
	消息队列--用于进程间的数据传输
	信号量--用于实现进程间的控制
1、管道(本质：内核中的一块缓冲区)
半双工(可以选择方向的单向通信)通信实现数据传输
通过让多个进程都能访问到同一块缓冲区来实现进程间通信
分类：
	匿名管道：这块内存中的缓冲区没有标识，只能用于具有亲缘关系的进程间通信
		创建管道时，操作系统会提供两个操作句柄（文件描述符），其中一个用于从管道读取数据，一个向管道写入数据
		子进程通过赋值父进程的方式，获得到管道的操作句柄，从而实现访问同一个管道
		int pipe(int pipefd[2]); // 创建一个匿名管道，向用户通过参数pipefd返回管道的操作句柄
		pipefd[0] 用于从管道读取数据
		pipefd[1] 用于向管道写入数据
		返回值：0<-->成功  -1<-->失败
		管道特性：若管道中没有数据，则read会阻塞；若管道写满了，则write会阻塞；管道自带同步与互斥
			同步：对临界资源访问的合理性
			互斥：通过保证同一时间只有一个进程能够访问临界资源，保证临界资源访问的安全性
		对管道进行数据操作的大小不超过PIPE_BUF(=4096)的时候，则保证操作的原子性
		若管道所有的写端被关闭，表示当前没有进程继续写入数据了，read读完管道中的数据之后，就不会再阻塞，而是返回0
		若管道所有的读端被关闭，表示没有进程读取数据了，继续write会触发异常，程序退出
	命名管道：内核中的缓冲区具有标识符（标识符是一个可见于文件系统的管道文件）
		其它进程可以通过这个标识符，找到这块缓冲区（通过打开同一个管道文件，进而访问到同一块缓冲区），进而实现通信
		命令操作: mkfifo filename
		int mkfifo(const char* pathname, mode_t mode); // 创建命名管道文件
		pathname：管道文件名称   mode 文件权限
		返回值：0<-->成功 -1<-->失败
		打开特性：若管道文件以只读的方式打开，则会阻塞，直到这个管道文件被以写的方式打开
			若管道文件以只写的方式打开，则会阻塞，直到这个管道文件被以读的方式打开
			若管道以读写的方式打开，则不会阻塞
		管道特性：管道生命周期随进程，半双工通信，自带同步与互斥，
			提供字节流服务（有序、连接、可靠的字节流传输）--传输比较灵活
2、共享内存
最快的进程间通信方式
	1）在物理内存上开辟一块内存空间
	2）将这块物理内存映射到进程的虚拟地址空间
	3）进程就可以通过虚拟地址直接访问这块物理内存
	多个进程要是映射到同一块物理内存，就可以通过这块内存实现数据共享
	共享内存之所以是最快的进程间通信方式，是因为共享内存直接通过虚拟地址映射访问物理内存，
	而其他方式因为都是内核中的缓冲区，因此通信时都会涉及用户态和内核态之间的两次数据拷贝，
	因为少了两次用户态与内核态的数据拷贝，因此通信速度最快
共享内存的操作流程:
	1）创建共享内存（开辟物理内存空间--具有标识符）
	2）将共享内存映射到各个进程的虚拟地址空间
	3）直接通过虚拟地址进行内存操作
	4）解除映射关系
	5）删除共享内存
	int shmget(key_t key, int size, int flag); // 创建共享内存
	key 共享内存的标识，多个进程通过相同的标识符可以打开同一块共享内存
	size 共享内存大小
	flag IPC_CRATE | IPC_EXCL | 权限
	返回值：成功返回一个操作句柄，失败返回-1
	void *shmat(int shmid, void *addr, int flag);
	shmid 共享内存操作句柄
	addr 映射到虚拟地址空间的首地址，通常置NULL
	flag 通常置0-可读可写 SHM_RDONLY-只读
	返回值：成功返回映射的虚拟空间首地址，通过这个地址对内存进行操作，失败返回-1
	int shmdt(void *shmstart); // 解除共享内存的映射
	shmstart 映射到虚拟地址空间的首地址
	成功返回0，失败返回-1
	int shmctl(int shmid, int cmd, struct shmid_ds *buf);
	shmid 操作句柄
	cmd 具体对共享内存要进行的操作 -- IPC_RMID-删除共享内存
	成功返回0，失败返回-1
	ipcs--查看进程间资源 	ipcrm--删除进程间通信资源
	-m 查看共享内存
	-q 查看消息队列
	-s 查看信号量
	ipcrm -m [shmid]
	当删除共享内存的时候，共享内存并不会立即被删除，因为有可能会造成正在访问的进程崩溃，
	而是将key修改为0，表示这块共享内存将不再继续接收映射链接，当这块共享内存的映射链接数为0的时候，则会自动释放
特性：
	1）最快的进程间通信方式
	2）生命周期随内核
注意事项：
	共享内存的操作是不安全的，并不会自动具备同步与互斥关系，需要操作用户进行控制
3、消息队列
本质上就是内核中的一个队列，多个进程通过向一个队列中添加节点和获取节点实现通信
传输一个有类型（优先级）的数据块
特性：
	1）自带同步与互斥
	2）生命周期随内核
	3）数据传输自带优先级
	msgget	创建
	msgsnd	添加节点
	msgrcv	获取节点
	msgctl	操作-删除消息队列 IPC_RMID
注意事项：
	struct msgbuf{ int type; char buf[***]; }; 这个结构体需要用户自己定义
4、信号量
用于实现进程间的同步与互斥
互斥：保证同一时间只有一个进程访问临界资源，实现临界资源的互斥访问保证安全性
同步：通过一种条件的判断，不能访问则等待，能访问再唤醒，实现对临界资源访问的合理性
本质：内核中的一个计数器（对资源进行计数）
互斥的实现：通过只有0/1的计数器，实现对临界资源访问的标记；在访问临界资源之前先获取信号量，计数-1；
	若计数小于0，则使进程等待（将进程pcb加入队列中）；否则则可以对临界资源进行访问（并且在访问期间，
	已经将临界资源的状态置位不可访问状态，因此可以保证其它进程不会再访问临界资源），
	当前进程访问完毕后，则对计数进行+1，唤醒一个进程（将一个pcb出队，置位运行状态）
同步的实现：信号量是一个对资源的计数，可以通过计数判断是否能够获取一个资源进行处理；
	若计数小于0，则表示不能获取（并且对计数进行-1），需要等待（加入pcb队列），
	这时候若其他进程生产一个资源，则会对计数进行+1，若计数小于等于0，则唤醒一个进程