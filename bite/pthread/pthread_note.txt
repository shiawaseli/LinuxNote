多线程: 线程概念、线程控制、线程安全、线程池
1、线程概念
在传统操作系统上pcb是一个进程，描述一个程序的运行，还有一个tcb描述实现线程
但是在Linux下使用pcb描述实现了程序调度，并且这些pcb共用同一个虚拟地址空间
相较于传统的pcb更加轻量化一点，因此也把Linux下的pcb称之为轻量级进程
进程是系统资源分配的基本单位，线程是CPU调度的基本单位
线程间的独有与共享:
独有: 栈、寄存器、信号屏蔽字、errno、标识符
共享: 虚拟地址空间（代码段、数据段）、文件描述符表、信号处理方式、工作路径、用户ID、组ID
多线程/多进程进行多任务处理：
多线程:
	1）线程间通信更加方便灵活（全局变量、函数传参）
	2）线程的创建/销毁成本更低
	3）线程间的调度成本更低
	4）异常和某些系统调用针对的是整个进程
多进程:
	具有独立性，因此更加的稳定、健壮   --shell/服务器
例如: 对主功能程序安全稳定性要求更高的最好使用多进程，剩下的多线程
共同优点:
	在CPU资源足够的情况下，可以使程序的性能更高（并非线程越多越好，调度的时间成本）
	例：CPU密集型程序/IO密集型程序  并行压缩CPU处理/IO等待时间
2、线程控制
线程创建、线程终止、线程等待、线程分离
线程控制的接口都是库函数，操作系统并没有向用户提供一个轻量级进程的接口，因此大佬们才封装了一套线程控制接口
使用时需要链接库文件 -lpthread/-pthread
线程创建:
	int pthread_create(pthread_t *tid, pthread_attr_t *attr, void* (*thread_routine)(void *arg), void *arg);
	tid 用于获取线程id，通过这个id可以找到线程的描述信息，进而访问pcb（轻量级进程完成控制）
	attr 线程属性，通常置NULL
	thread_routine 线程入口函数，创建一个线程就是为了运行这个函数，函数运行完毕，则线程退出
	arg 通过线程入口函数，传递给线程的参数
	返回值: 0<->成功 非0值<->失败返回(errno)
ps -L： 功能是查看轻量级进程信息 ps -efL
	pcb-> 	pid 轻量级进程ID <-> LWP（light weight process）
	pcb-> 	tgid 线程组ID <-> 进程id，也就是外边命令所看到的进程id；而这个id值等于主线程的pcb->pid
		tid 线程在虚拟地址空间中开辟的线程空间的首地址
线程终止:
	1）普通线程入口函数中的return（main函数中的return退出的是进程）
	2）void pthread_exit(void *retval); // 退出一个线程，谁调用，谁退出，retval--线程返回值
	3）int pthread_cancel(pthread_t tid); // 退出指定的线程；tid就是指定的线程id
	注意:
	1、线程退出，也不会完全释放资源，需要被其它进程等待
	2、取消自己是一种违规操作，不是主流做法（了解）
	3、主线程退出，其它线程正常退出，也不是主流做法（了解）
	4、主线程退出，并不影响整个进程的运行，只有所有的线程退出，进程才退出
线程等待:
	等待一个线程的退出，获取退出线程的返回值，回收这个线程所占用的资源
	int pthread_join(pthread_t tid, void **retval);
	tid 指定要等待的线程id
	retval 用于获取线程退出返回值  <->  pthread_exit(void *retval)
	不是所有的线程都能被等待，一个线程被创建，默认情况下有一个属性--joinable；
	处于joinable属性的线程退出后，不会自动释放资源，需要被等待
线程分离：
	将线程的属性从joinable设置为detach；处于detach属性的线程退出后会自动释放资源，不需要被等待
	int pthread_detach(pthread_t tid); // 分离指定的线程
	等待一个被分离的线程，则pthread_join会返回错误：这不是一个joinable线程
	因为在获取返回值的时候将获取不到，detach属性的线程退出后已经自动的释放了资源
	1）线程的分离可以在任意地方，可以在线程入口函数中让线程分离自己，也可以在创建线程后分离，如何选择取决于个人习惯
3、线程安全
在多个执行流中对同一个临界资源进行操作访问，而不会造成数据二义
如何实现线程安全：同步与互斥
互斥：通过保证同一时间只有一个执行流可以对临界资源进行访问（一个执行流访问期间，其它执行流不能访问），来保证数据访问的安全性
同步：通过一些条件判断来实现多个执行流对临界资源访问的合理性（有资源则访问，没有资源则等着，等有资源了再被唤醒）
如何实现互斥：互斥锁
如何实现同步：条件变量 --posix标准的信号量
互斥锁：定义一个互斥锁用来标记当前临界资源的访问状态
	有一个技术器：0/1   0-不可访问  1-可以访问	计数器初值为1。
	每一个线程访问临界资源之前，先判断计数，当前临界资源的状态（是否有人正在访问--正在访问的线程将状态置位为0）
	1）第一个线程访问的时候，判断可以访问，因此将状态置位为不可访问，然后去访问资源
	2）其它线程访问的时候，发现不可访问，就陷入等待（等待：将pcb状态置为可中断休眠态，则不可被操作系统调度）
	3）第一个线程访问临界资源完毕后，将状态置位为可以访问，唤醒等待的线程，大家重新开始竞争这个资源（唤醒：将pcb状态置为运行态，则可以开始调度）
	伪代码：
		xchgb	%al count
		if (寄存器的值>0) {
			return ;
		}
	pthread_mutex_t 互斥锁变量类型
	pthread_mutex_init(pthread_mutex_t *mutex, pthread_mutexattr_t *attr); // 初始化互斥锁
	pthread_mutex_lock(pthread_mutex_t *mutex); // 在临界资源访问之前加锁
	pthread_mutex_unlock(pthread_mutex_t *mutex); // 在临界资源访问完毕后解锁
	pthread_mutex_destory(pthread_mutex_t *mutex); // 销毁互斥锁
	pthread_mutex_trylock(...) / pthread_mutex_timedlock(...)
同步的实现：保证资源访问的合理性
	有资源的时候可以获取，没有资源的时候则需要让线程等待，等待被唤醒（其它线程产生一个资源的时候）
条件变量：向用户提供了两个接口，使一个线程等待的接口和唤醒一个线程的接口 + 等待队列
	条件变量只是提供了等待与唤醒的功能，但是什么时候等待，什么时候唤醒，需要用户自己来做判断